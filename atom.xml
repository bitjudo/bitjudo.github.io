<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[bitJudo]]></title>
  <link href="http://bitjudo.com/atom.xml" rel="self"/>
  <link href="http://bitjudo.com/"/>
  <updated>2014-04-02T13:54:02-04:00</updated>
  <id>http://bitjudo.com/</id>
  <author>
    <name><![CDATA[a couple of geeks]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Just in Time Encryption Keys using SaltStack]]></title>
    <link href="http://bitjudo.com/blog/2014/03/19/just-in-time-encryption-keys-using-saltstack/"/>
    <updated>2014-03-19T11:15:00-04:00</updated>
    <id>http://bitjudo.com/blog/2014/03/19/just-in-time-encryption-keys-using-saltstack</id>
    <content type="html"><![CDATA[<p>Recently, I was challenged with ensuring the encryption of all data at rest for several servers.  Unlike laptops or desktops, server nodes need to be able to come up and down in response to various requests. When spinning up multiple nodes you definitely don’t want them waiting for human interaction. Enter SaltStack and LUKS volumes. The real challenge was how to provide full disk encryption without storing the encryption key itself on the server.</p>

<p>Since these were Linux servers, LUKS encryption made the most sense. In essence what this tutorial describes is a way to provide “just in time” delivery of disk encryption keys. This is done using SaltStack features.</p>

<p>The rest of this article is a TL;DR combined with a tutorial of sorts to help you set this up.</p>

<h1>TL;DR</h1>

<p>By taking advantage of a couple features that <a href="http://www.saltstack.com/">SaltStack</a> brings to the table, it is possible to automate the mounting of your LUKS volumes after the server has started. The salt minion has the ability to run certain states (scripts) upon start.  This allows the user to run a LUKS state that will verify the existence of the volume, unlock it, and mount it. Using salt states also allows the user to build state dependencies, or trigger other states to run.  These features ensure that any services requiring the encrypted volume only start after the volume is available.</p>

<!-- more -->


<h1>How it Works</h1>

<p>Upon initializing of SaltStack, the configuration tells the Salt minion to run two scripts.  One script is the LUKS encryption script, which confirms that the LUKS volume exists, then unlocks and mounts it.  When the LUKS script runs, it requests pillar data from the Salt master.  Included in the requested data is the LUKS encryption key, which is transferred using zeromq and AES encryption. The key is temporarily stored locally on the minion while the script runs, and is deleted upon completion.</p>

<p>The second script checks whether a particular service is dependent upon the encrypted volume is running.  If the specific service is found to not be running, the script will also initialize it.  In this particular case, the service is a mongodb service.</p>

<p>Ultimately, we end up with the ability to mount an encrypted drive and start dependent services.  However, we have relegated the encryption key to a single separate server and only temporarily transfer it to the servers that need it, exactly when they need it.  In simpler terms, we’ve created a just-in-time delivery mechanism for an encryption key.  While this method may not be bulletproof, I have found it preferable to storing the encryption key permanently on the same server as the paired encrypted drive.</p>

<h1>The Quasi How-To</h1>

<p>The below does not cover setup and/or configuring SaltStack, LVM or LUKS encryption.  Rather, it’s an example of salt state and pillar files, some steps you can use to get going. It should be pretty straightforward.</p>

<h2>The Salt State</h2>

<p>I originally found this state and after a little bit of searching I cannot find the original place I found it, but I ended up modifying it a bit for my needs. If you know where it originally came from, let me know and I’ll make a note. The state ensures that the LVM I need is setup and then sets up the LUKS volume. If all that is already setup then the script will simply unlock and mount the LUKS volume at the the defined mount point.</p>

<p><em>Assumptions:</em> You have a non-formatted drive attached to the server and you&rsquo;ve defined that in your pillar data, make sure you assign the correct drive device, otherwise you might end up erasing data.</p>

<div><script src='https://gist.github.com/9541650.js?file=luks.state'></script>
<noscript><pre><code>{% set password = pillar['encryption']['password'] %}
{% set devname = pillar['encryption']['dev_name'] %}
{% set volgroup = pillar['encryption']['vg_name'] %}
{% set mountpoint = pillar['encryption']['mountpoint'] %}

crypto-package:
  pkg:
    - name: cryptsetup
    - order: 10
    - installed

lvm2-package:
  pkg:
    - name: lvm2
    - order: 11
    - installed

{{ devname }}:
  lvm.pv_present:
    - order: 12

vg{{ volgroup }}:
  lvm.vg_present:
    - devices: {{ devname }}
    - order: 13

lv{{ mountpoint }}:
  cmd.run:
    - unless: lvdisplay /dev/vg{{ volgroup}}/lv{{ volgroup }}
    - name: lvcreate -l 100%FREE -n lv{{ volgroup }} vg{{ volgroup }}
    - order: 14

enc_volume:
  cmd.run:
    - unless: cryptsetup luksUUID /dev/vg{{ volgroup }}/lv{{ mountpoint }}
    - name: echo &quot;{{ password }}&quot; | cryptsetup luksFormat /dev/vg{{ volgroup }}/lv{{ mountpoint }}
    - order: 15

enc_volume_open:
  cmd.run:
    - unless: stat /dev/mapper/{{ mountpoint }}
    - name: echo &quot;{{ password }}&quot; | cryptsetup luksOpen /dev/vg{{ volgroup }}/lv{{ mountpoint }} {{ mountpoint }}
    - order: 16

enc_volume_format:
  cmd.run:
    - unless: lsblk -f /dev/mapper/{{ mountpoint }} | grep ext4
    - name: mkfs.ext4 /dev/mapper/{{ mountpoint }}
    - order: 17

enc_volume_mount:
  mount.mounted:
    - name: /{{ mountpoint }}
    - device: /dev/mapper/{{ mountpoint }}
    - fstype: ext4
    - mkmnt: True
    - opts: noatime,nodiratime
    - persist: False
    - order: 18
</code></pre></noscript></div>


<p><strong>Note:</strong> Please note that this state will create the LVM physical and logical volumes or attempt too if that fails LUKS and mounting will fail too.</p>

<p><strong>Caveat:</strong> This script will initialize a single drive as part of an LVM, with some tweaking it could combine multiple drives. This script was design to bring a server up from scratch and have a LUKS volume mounted and ready to go.</p>

<h3>Extra Credit</h3>

<p>If you want to learn how to make states reliant on each other check out the <code>requires</code> directive in the salt documentation. If you want to notify states when another state is done running check out <code>require_in</code>.</p>

<h2>The Salt Pillar</h2>

<p>The pillar contains the configuration for the LVM and LUKS volumes and the mount point. Ensuring that you populate this pillar with the appropriate data is important.</p>

<ul>
<li><strong>password</strong> is the encryption key for the LUKS volume.</li>
<li><strong>vg_name</strong> is used to define both the volume group but the logical volume name too.</li>
<li><strong>mountpoint</strong> is where you want the LVM and LUKS volume to be mounted.</li>
<li><strong>dev_name</strong> is the device that you want converted to LVM and then LUKS encrypted.</li>
</ul>


<div><script src='https://gist.github.com/9541650.js?file=luks.pillar'></script>
<noscript><pre><code>encryption:
  password: some_random_long_string
  dev_name: /dev/sda1
  vg_name: data
  mountpoint: data</code></pre></noscript></div>


<p><strong>Note:</strong> I don&rsquo;t discuss how to do it, but you can duplicate this pillar and change the <strong>password</strong> for each server if you want.</p>

<h2>Putting it all together</h2>

<p>Assuming you&rsquo;ve associated the salt state and pillar to the appropriate target you&rsquo;ll be able to use <code>highstate</code> or <code>state.sls</code> to setup your LUKS encrypted drive. To make sure this happens each time the server starts up make sure you edit the minion&rsquo;s configuration and setup <code>startup_states</code> to <em>highstate</em>.</p>

<p>You should be able to tell the minion to run the LUKS state and find your drive mounted. Once that happens do a quick reboot, you should also find a few seconds to a minute after reboot your drive is mounted and accessible.</p>

<h1>Conclusion</h1>

<p>I&rsquo;m pretty happy with this solution, it allows my servers to be rebooted without human interaction and for the critical services to come online once their data is available. It keeps the encryption key from having to be stored on the server. Using this strategy you could easily expand this for other encryption technologies.</p>

<p>Thoughts, comments, questions? Let me hear from you. Leave your comments below.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Building Efficient Dockerfiles - Node.js]]></title>
    <link href="http://bitjudo.com/blog/2014/03/13/building-efficient-dockerfiles-node-dot-js/"/>
    <updated>2014-03-13T09:34:02-04:00</updated>
    <id>http://bitjudo.com/blog/2014/03/13/building-efficient-dockerfiles-node-dot-js</id>
    <content type="html"><![CDATA[<h1>TL;DR</h1>

<p>Use the following code snippet (or a variation) after all your app dependencies
but before you ADD your app code to the container&hellip; this way you don&rsquo;t rebuild
your modules each time you re-build your container. If your <code>package.json</code> file
changes then your modules will be rebuilt. See this
<a href="https://gist.github.com/dweinstein/9550188">gist</a> for a full example.</p>

<figure class='code'><figcaption><span>Add this to your Dockerfile, after your deps, but before your app code.</span><a href='https://gist.github.com/dweinstein/9468644'>gist </a></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='text'><span class='line'>ADD package.json /tmp/package.json
</span><span class='line'>RUN cd /tmp &amp;&amp; npm install
</span><span class='line'>RUN mkdir -p /opt/app &amp;&amp; cp -a /tmp/node_modules /opt/app/
</span></code></pre></td></tr></table></div></figure>


<h1>Using cached layers for modules</h1>

<p>This article is about making efficient use of docker layers. As a side effect
we&rsquo;ll see how to reduce development and debugging time for Node.js applications
hosted in Docker containers. As you migrate from developing everything on your
development host system to Docker, there are some growing pains&hellip; mainly
arround interactive modify-and-test workflows.</p>

<!-- more -->


<p>There was a time that whenever I&rsquo;d make a slight modification to an application
I&rsquo;d spend time waiting for docker containers to rebuild. Usually I was waiting
for the modules to be reinstalled.  I spent more time waiting for the
dependencies to build than actually fixing the problem. I hope this article
helps others get out of that cycle&hellip;</p>

<p><span class='pullquote-right' data-pullquote='Docker forces you to think a differently. Once you get in
the right mindset you&#8217;ll find yourself inventing new tricks.'></p>

<p>Writing an efficient <code>Dockerfile</code> is part of the fun of working with Docker as
a new technology. Docker forces you to think a differently. Once you get in
the right mindset you&rsquo;ll find yourself inventing new tricks.</p>

<p></span></p>

<p>One key is to understand how Docker layers work. For now, visit the
<a href="http://docs.docker.io/en/latest/terms/layer/">documentation</a> to see a graphic
showing the various layers involved with Docker. Commands in your <code>Dockerfile</code>
will create new layers. When possible, docker will try to use an existing
cached layer if it&rsquo;s possible. You should try to take advantage of layers as
much as possible by organizing your commands in a specific order. We&rsquo;ll get
into that order in a second for dealing with node modules in your application.</p>

<p>First here&rsquo;s an example dependency file for Node:</p>

<figure class='code'><figcaption><span>Example - package.json </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="s2">&quot;name&quot;</span><span class="o">:</span> <span class="s2">&quot;myApp&quot;</span><span class="p">,</span>
</span><span class='line'>  <span class="s2">&quot;description&quot;</span><span class="o">:</span> <span class="s2">&quot;This is my awesome app...&quot;</span><span class="p">,</span>
</span><span class='line'>  <span class="s2">&quot;version&quot;</span><span class="o">:</span> <span class="s2">&quot;0.0.1&quot;</span><span class="p">,</span>
</span><span class='line'>  <span class="s2">&quot;private&quot;</span><span class="o">:</span> <span class="kc">true</span><span class="p">,</span>
</span><span class='line'>  <span class="s2">&quot;scripts&quot;</span><span class="o">:</span> <span class="p">{</span>
</span><span class='line'>    <span class="s2">&quot;start&quot;</span><span class="o">:</span> <span class="s2">&quot;node server.js&quot;</span>
</span><span class='line'>  <span class="p">},</span>
</span><span class='line'>  <span class="s2">&quot;dependencies&quot;</span><span class="o">:</span> <span class="p">{</span>
</span><span class='line'>    <span class="s2">&quot;docker.io&quot;</span><span class="o">:</span> <span class="s2">&quot;*&quot;</span><span class="p">,</span>
</span><span class='line'>    <span class="s2">&quot;redis&quot;</span><span class="o">:</span> <span class="s2">&quot;*&quot;</span><span class="p">,</span>
</span><span class='line'>    <span class="s2">&quot;restify&quot;</span><span class="o">:</span> <span class="s2">&quot;*&quot;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>And here&rsquo;s what we&rsquo;re going to insert into our old Dockerfile:</p>

<figure class='code'><figcaption><span>Add this to your Dockerfile, after your deps, but before your app code.</span><a href='https://gist.github.com/dweinstein/9468644'>gist </a></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='text'><span class='line'>ADD package.json /tmp/package.json
</span><span class='line'>RUN cd /tmp &amp;&amp; npm install
</span><span class='line'>RUN mkdir -p /opt/app &amp;&amp; cp -a /tmp/node_modules /opt/app/
</span></code></pre></td></tr></table></div></figure>


<p>This snippet should generally go after all dependencies of your application
are installed, but just before you add your application&rsquo;s code to the
container.</p>

<p>A <em>bad</em> <code>Dockerfile</code> could look like this:</p>

<div><script src='https://gist.github.com/9550778.js'></script>
<noscript><pre><code>FROM ubuntu

RUN echo &quot;deb http://archive.ubuntu.com/ubuntu precise main universe&quot; &gt; /etc/apt/sources.list
RUN apt-get update
RUN apt-get -y install python-software-properties git build-essential
RUN add-apt-repository -y ppa:chris-lea/node.js
RUN apt-get update
RUN apt-get -y install nodejs

WORKDIR /opt/app

ADD . /opt/app

RUN npm install

EXPOSE 3001

CMD [&quot;node&quot;, &quot;server.js&quot;]</code></pre></noscript></div>


<p>This is bad because we copy the app&rsquo;s working directory  on <a href="https://gist.github.com/dweinstein/9550778#file-bad-dockerfile-L12">line
12</a>&mdash;which
has our <code>package.json</code>&mdash;<code>.</code> to our container and then build the modules. This
results in our modules being built everytime we make a change to a file in <code>.</code>.</p>

<p>Here&rsquo;s a full example of a better implementation:</p>

<div><script src='https://gist.github.com/9550188.js?file=Dockerfile'></script>
<noscript><pre><code>FROM ubuntu
MAINTAINER David Weinstein &lt;david@bitjudo.com&gt;

# install our dependencies and nodejs
RUN echo &quot;deb http://archive.ubuntu.com/ubuntu precise main universe&quot; &gt; /etc/apt/sources.list
RUN apt-get update
RUN apt-get -y install python-software-properties git build-essential
RUN add-apt-repository -y ppa:chris-lea/node.js
RUN apt-get update
RUN apt-get -y install nodejs

# use changes to package.json to force Docker not to use the cache
# when we change our application's nodejs dependencies:
ADD package.json /tmp/package.json
RUN cd /tmp &amp;&amp; npm install
RUN mkdir -p /opt/app &amp;&amp; cp -a /tmp/node_modules /opt/app/

# From here we load our application's code in, therefore the previous docker
# &quot;layer&quot; thats been cached will be used if possible
WORKDIR /opt/app
ADD . /opt/app

EXPOSE 3000

CMD [&quot;node&quot;, &quot;server.js&quot;]
</code></pre></noscript></div>


<p>The idea here is that if the <code>package.json</code> file changes (<a href="https://gist.github.com/dweinstein/9550188#file-dockerfile-L14">line
14</a>) then
Docker will re-run the <code>npm install</code> sequence (<a href="https://gist.github.com/dweinstein/9550188#file-dockerfile-L15">line
15</a>)&hellip;
otherwise Docker will use our cache and skip that part.</p>

<p>Here&rsquo;s a log showing how building our Docker container is now using the <code>cache</code>
for the module dependency step when building the Dockerfile shown earlier.</p>

<div><script src='https://gist.github.com/9550105.js'></script>
<noscript><pre><code>Uploading context 4.608 kB
Uploading context 
Step 0 : FROM ubuntu
 ---&gt; 9cd978db300e
Step 1 : MAINTAINER David Weinstein &lt;david@bitjudo.com&gt;
 ---&gt; Using cache
 ---&gt; 67aeca8f12ae
Step 2 : RUN echo &quot;deb http://archive.ubuntu.com/ubuntu precise main universe&quot; &gt; /etc/apt/sources.list
 ---&gt; Using cache
 ---&gt; be8f73b1204f
Step 3 : RUN apt-get update
 ---&gt; Using cache
 ---&gt; 70395f80789a
Step 4 : RUN apt-get -y install python-software-properties git build-essential
 ---&gt; Using cache
 ---&gt; 58821e45ea25
Step 5 : RUN add-apt-repository -y ppa:chris-lea/node.js
 ---&gt; Using cache
 ---&gt; 79afb0c0539a
Step 6 : RUN apt-get update
 ---&gt; Using cache
 ---&gt; 18fc6aa866d8
Step 7 : RUN apt-get -y install nodejs
 ---&gt; Using cache
 ---&gt; 1f1f41f47329
Step 8 : ADD package.json /tmp/package.json
 ---&gt; Using cache
 ---&gt; 0331fd81b4c8
Step 9 : RUN cd /tmp &amp;&amp; npm install
 ---&gt; Using cache
 ---&gt; 95ee8b27b72b
Step 10 : RUN mkdir -p /opt/app &amp;&amp; cp -a /tmp/node_modules /opt/app/
 ---&gt; Using cache
 ---&gt; 40102f5ce4f1
Step 11 : WORKDIR /opt/app
 ---&gt; Using cache
 ---&gt; 6a1ad0dca915
Step 12 : ADD . /opt/app
 ---&gt; 6b9bdaa0e7a2
Step 13 : EXPOSE 3000
 ---&gt; Running in 722c8f0b88e2
 ---&gt; d97a3d372bda
Step 14 : CMD [&quot;node&quot;, &quot;server.js&quot;]
 ---&gt; Running in 3309a2dab1cc
 ---&gt; a0b19d7625d3
Successfully built a0b19d7625d3
</code></pre></noscript></div>


<p>This whole example is contained in this
<a href="https://gist.github.com/dweinstein/9550188">gist</a> so that you can repeat it
exactly as I have.</p>

<p>Assuming you&rsquo;ve built the container once before (i.e., <code>docker build -t
testProject .</code>), and then uncommented <a href="https://gist.github.com/dweinstein/9550188#file-server-js-L7">line
7</a> in our example
<code>server.js</code> the  above log shows what happens when we rebuild our container,
i.e., simulating a change to our app&rsquo;s logic. Looking at the log, on <a href="https://gist.github.com/dweinstein/9550105#file-gistfile1-txt-L32">line
32</a> the
<code>cache</code> was used but on <a href="https://gist.github.com/dweinstein/9550105#file-gistfile1-txt-L38">line
38</a> the
cache was <em>not</em> used&hellip;</p>

<h1>Conclusion</h1>

<p>Now our modules are cached so we aren&rsquo;t rebuilding them every time we change
our apps source code! This will speed up testing and debugging nodejs apps.
Also this caching technique can work for ruby gems which we&rsquo;ll talk about in
another post.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Authentication for a Docker Registry]]></title>
    <link href="http://bitjudo.com/blog/2014/03/12/authentication-for-a-docker-registry/"/>
    <updated>2014-03-12T10:48:18-04:00</updated>
    <id>http://bitjudo.com/blog/2014/03/12/authentication-for-a-docker-registry</id>
    <content type="html"><![CDATA[<p>Docker is an amazing tool that has only been around for a short while, but has taken the DevOps world by storm, and organizations from small to large are starting to use it from integration testing, to dynamically scaling an application&rsquo;s environment.</p>

<p>Docker released an open-source registry that allows you to remote store images you create with docker, but what the did not release is an open-source index. The index is arguably (depending on your use case) the most important part, it handles the authentication layer of a registry. A registry can be used without and index, and if you are just wanting a place to store your images and you don&rsquo;t want to worry about who can access them, then no need to read on.</p>

<!-- more -->


<p>For my job I needed a way to host images securely, but still allow various people inside and outside my organization to access certain images, so in my spare time (and since no one had done it yet that I could find) I started writing an index using Node.JS. It is currently in its infancy, but it works as of right now.</p>

<p>The project lives on github at <a href="https://github.com/ekristen/docker-index">docker-index</a> and it is setup as a trusted build and deployed to the public docker registry/index at <a href="https://index.docker.io/u/ekristen/docker-index/.">https://index.docker.io/u/ekristen/docker-index/.</a> Just run <code>docker pull ekristen/docker-index</code> to get started. Specific instructions on how to get the registry, index, and redis working together can be found on the project&rsquo;s <a href="https://github.com/ekristen/docker-index/blob/master/README.md#how-to-use">README</a></p>

<p>It has only one dependency at this time and that is redis, that will most likely change to use mongodb or maybe even mysql to store users, permissions, and other index data, but redis was a quick and simple medium when doing the intial prototyping.</p>

<p>My future plans for the index are to create an admin interface that facilitates the management of users, namespaces, repositories and their associate permissions. For now all that has to be done by editing the configuration file.</p>

<p>This was a big help for me, hopefully having this code out there can help others too.</p>

<p>If you are interested in helping out pull requests are always welcome. If you have feedback, let me know.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Docker Scripts]]></title>
    <link href="http://bitjudo.com/blog/2014/03/11/docker-scripts/"/>
    <updated>2014-03-11T19:37:06-04:00</updated>
    <id>http://bitjudo.com/blog/2014/03/11/docker-scripts</id>
    <content type="html"><![CDATA[<p>David (the other author on this blog) and I have been doing a lot of work with docker with respect to our daily jobs. We ended up needed to orchestrate the management of multiple docker containers. This was before we discovered projects like <a href="https://github.com/toscanini/maestro">maestro</a> and <a href="https://github.com/signalfuse/maestro-ng">maetro-ng</a>. David found an awesome command line for parsing json called <a href="http://stedolan.github.io/jq/">jq</a> and put it to use by creating a bash one liner to grab a container&rsquo;s IP address.</p>

<!-- more -->




<figure class='code'><figcaption><span>docker-get-ip </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="c"># Usage: docker-get-ip (name or sha)</span>
</span><span class='line'><span class="o">[</span> -n <span class="s2">&quot;$1&quot;</span> <span class="o">]</span> <span class="o">&amp;&amp;</span> docker inspect <span class="nv">$1</span> | jq -r <span class="s1">&#39;.[0] | .NetworkSettings | .IPAddress&#39;</span>
</span></code></pre></td></tr></table></div></figure>


<p>I took it one step further and created several more one liners to get other various pieces of information from containers.</p>

<figure class='code'><figcaption><span>docker-get-id </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="c"># Usage: docker-get-id (friendly-name)</span>
</span><span class='line'><span class="o">[</span> -n <span class="s2">&quot;$1&quot;</span> <span class="o">]</span> <span class="o">&amp;&amp;</span> docker inspect <span class="nv">$1</span> | jq -r <span class="s1">&#39;.[0] | .ID&#39;</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span>docker-get-port </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="c"># Usage: docker-get-port (name|sha) port/protocol</span>
</span><span class='line'><span class="o">[</span> -n <span class="s2">&quot;$1&quot;</span> <span class="o">]</span> <span class="o">&amp;&amp;</span> docker inspect <span class="nv">$1</span> | jq -r <span class="s2">&quot;.[0] | .NetworkSettings | .Ports | .[\&quot;$2\&quot;] | .[0] | .HostPort&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>The great news is that with <code>jq</code>, you can create simple one liners for just about anything with the <code>docker inspect</code> command and drop them in <code>/usr/local/bin</code> and make your administrative life a little easier. I&rsquo;m sure there are more useful ones, but those are the top 3 that David and I use that make things more simple.</p>
]]></content>
  </entry>
  
</feed>
